    // const pointOffet = useRef<Point>({x: 0, y: 0})  // 框偏移量
  // const isDragging = useRef(false)  // 是否正在通过鼠标拖动框
  // const isResizing = useRef(false)  // 是否正在通过鼠标调整框大小
  // const boxStartRef = useRef<Point>({x: 0, y: 0})  // 框开始点


  
  /** 鼠标按下事件, 临时注释掉 */
  const handleMouseDown = (e: React.MouseEvent) => {
    // if (!canvasRef.current) return
    // const rect = canvasRef.current.getBoundingClientRect();
    // const x = e.clientX - rect.left;
    // const y = e.clientY - rect.top;
    // const point = getRelPoint(canvasRef.current, {x, y})
    
    // // 鼠标点按边角
    // const cornerCollision = pointCollidesBoxCorner(point, boxesRef.current)
    // if (cornerCollision > -1) {
    //   tgBoxIdx.current = cornerCollision
    //   isResizing.current = true
    //   boxStartRef.current = {x: boxesRef.current[cornerCollision].sx, y: boxesRef.current[cornerCollision].sy}
    //   return
    // }

    // // 鼠标点按框内
    // const collision = pointCollidesBox(point, boxesRef.current)
    // if (collision > -1) {
    //   // move the collision box to the first element of array
    //   const box = boxesRef.current[collision]
    //   boxesRef.current.splice(collision, 1)
    //   boxesRef.current.unshift(box)

    //   tgBoxIdx.current = 0
    //   pointOffet.current = {
    //     x: point.x - box.sx, 
    //     y: point.y - box.sy
    //   }
    //   isDragging.current = true
    // } else {
    //   // 鼠标无点按任何框，则新增 - 更新中
    //   // boxesRef.current.push({sx: point.x, sy: point.y, w:0.01, h:0.02, label:labeltext?labeltext:'empty', color: randomColor()})
    //   tgBoxIdx.current = boxesRef.current.length -1
    //   isResizing.current = true
    //   boxStartRef.current = point
    //   // refresh()
    // }
  };

  /** 鼠标移动事件, 临时注释掉 */
  const mouseMoveBox = useCallback((e: React.MouseEvent<HTMLDivElement> | MouseEvent) => {
    // if (!e.currentTarget || !canvasRef.current) return
    // const rect = canvasRef.current.getBoundingClientRect();
    // const x = e.clientX - rect.left;
    // const y = e.clientY - rect.top;
    // const point = getRelPoint(canvasRef.current, {x, y})
    // const cornerCollision = pointCollidesBoxCorner(point, boxesRef.current)
    // if (cornerCollision > -1) {
    //   setCursor('nw-resize')
    // } else {
    //   setCursor('default')
    // }
    // if (tgBoxIdx.current === -1) return
    // if(!isDragging && !isResizing) return
    
    // const box = boxesRef.current[tgBoxIdx.current]
    // if(isDragging.current){
    //   box.sx = point.x - pointOffet.current.x
    //   box.sy = point.y - pointOffet.current.y
    //   boxesRef.current[tgBoxIdx.current] = box
    //   setCursor('move')
    // } else if (isResizing.current) {
    //   // 拖动改变框大小
    //   if(point.x < boxStartRef.current.x) {
    //     const box_r = boxStartRef.current.x
    //     box.w = box_r - point.x
    //     box.sx = point.x
    //   } else {
    //     const dx = point.x - box.sx
    //     box.w = Math.abs(dx)
    //   }
    //   if(point.y < boxStartRef.current.y) {
    //     const box_b = boxStartRef.current.y
    //     box.h = box_b - point.y
    //     box.sy = point.y
    //   } else { 
    //     box.h = Math.abs(point.y - box.sy)
    //   }
    //   boxesRef.current[tgBoxIdx.current] = box
    // }
    // refresh()
  }, [])

  /** 鼠标抬起事件, 临时注释掉 */
  const handleMouseUp = useCallback(() => {
    console.log('mouse up')
    // isDragging.current = false
    // isResizing.current = false
    // setCursor('default')

    // if (tgBoxIdx.current !== -1) {  // 框的尺寸过小则移除
    //   const box = boxesRef.current[tgBoxIdx.current]
    //   if(!box) return;
    //   if(box.w < 0.02 && box.h < 0.04){
    //     boxesRef.current.splice(tgBoxIdx.current, 1)
    //     tgBoxIdx.current = -1
    //   }
    //   refresh()
    // }
  }, []);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if(e.key === 'Escape' || e.key === 'q') {
      if (tgBoxIdx.current !== -1) {  // 框的尺寸过小则移除
        boxesRef.current.splice(tgBoxIdx.current, 1)
        tgBoxIdx.current = -1
        refresh()
      }
    }
  }, [])

  // useEffect(()=> {
  //   window.addEventListener('mouseup', handleMouseUp);
  //   window.addEventListener('mouseleave', handleMouseUp);
  //   window.addEventListener('mousemove', mouseMoveBox);
  //   return () => {
  //     window.removeEventListener('mouseup', handleMouseUp);
  //     window.removeEventListener('mouseleave', handleMouseUp);
  //     window.removeEventListener('mousemove', mouseMoveBox);
  //   }
  // }, [handleMouseUp, mouseMoveBox])


        // onMouseDown={handleMouseDown} 
      // onKeyDown={handleKeyDown}